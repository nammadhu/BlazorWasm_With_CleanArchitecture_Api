@page "/Town/{Id:int}"
@using Blazored.LocalStorage
@using MyTown.Domain
@using MyTown.RCL.Town
@using MyTown.RCL.Card
@using MyTown.RCL.CardType
@using MyTown.SharedModels.Features.Towns.Commands
@using MyTown.SharedModels.Features.Towns.Queries
@using MyTown.SharedModels.Features.Cards.Commands
@using System.Security.Claims
@inject TownService townService
@inject CardService cardService
@inject IStringLocalizer<TownDto> L

@* @inject AuthenticationStateProvider authenticationStateProvider *@
@inject ClientConfig clientConfig
@inject AuthService authService

@if (HeaderCard != null && HeaderCard.Id > 0)
    {
    <TownMainHeaderCardDisplay Model="@HeaderCard" />
    @* <TownCardDisplay Model="@((TownItemDto)Model)" ImageHeight=350 /> *@

    @if (Cards.Any())
        {
        @foreach (var group in Cards)
            {
            <StringDisplay Text="@group.TypeName" Typo="Typo.body1" />
            <MudCarousel Class="mud-width-full" ShowArrows="@true" ShowBullets="@true" EnableSwipeGesture="@true" AutoCycle="@true" TData="object"
                         Style="@($" color:{@Colors.Red.Default};height:50vh;mud-carousel;")">
                @foreach (var card in group.Cards)
                    {
                    <MudCarouselItem Transition="Transition.Slide">
                        <TownCardDisplay Model="@card" />  @* Style="height:200px;" *@
                    </MudCarouselItem>
                    }
            </MudCarousel>
            <MudSpacer />
            }
        }
    }
else
    {
    <MudText>Sorry No Data exists @(Name ?? "".ToUpper()) </MudText>
    }
<MudButton Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.AddCard" Style="background-color: yellowgreen; color: white; width: 200px; height: 60px;" OnClick="OnCreate">
    Add iCard
</MudButton>

<MudText><i> <small>To Add Your Content Send details to <ContactEmail /></small></i></MudText>

@code {
    [Parameter]
    public int Id { get; set; }//townid

    [Parameter]
    public string? Name { get; set; }//townname

    // [Inject] ILocalStorageService localStorageService { get; set; }

    private TownDto HeaderCard = new TownDto();//make offline
    private List<TownCardsGrouping> Cards = new List<TownCardsGrouping>();//make offline
    /*
    ALl anonymous page,
       1.OnInitialized() do anonymous call
       2.On parameterset do userspecific calls then set create/edit/delete button handling & all
    */
    protected override async Task OnInitializedAsync()
        {
        await LoadServerData();
        // await CheckAuthenticationStateAsync();
        }
    async Task LoadServerData()
        {
        var town = await townService.GetByIdAsync(townId: Id);
        if (town != null && town.Id > 0 && !string.IsNullOrEmpty(town.Name))
            {
            HeaderCard = town;//if offline then had to serve previous data itself
            if (town.ApprovedCards != null && town.ApprovedCards.Any())
                Cards = townService.GroupCardsByType(town);
            }
        }
    protected override async Task OnParametersSetAsync()
        {
        if (await authService.IsAuthenticatedAsync())
            {
            await authService.AuthorizeRoles();

            //all authenticated can add new unless he is blocked
            if (clientConfig.IsBlocked == true)
                {
                //then dont allow him for anything to do
                }

            //for admin all can edit
            //for others should have  only his own edit option
            if (clientConfig.IsAdmin == true || clientConfig.IsInternalAdmin == true || clientConfig.IsInternalViewer == true)
                {
                //todo later
                //let them can see card owner emailid,phone all
                //as one more call to fetch with all details
                }

            if (clientConfig.IsCardCreator == true || clientConfig.IsCardOwner == true || clientConfig.IsCardReviewer == true)//owner or creator then only edit/delete check call had to be done
                {
                
                //do one more call to api to check & store locally list of cardid
                //input is townid
                //fetchmycards(townid,creator:bool,owner:bool,reviewer:bool),
                // returns List<cardid of Approved>
                // ,also if any draft cards,
                //also any pending for my approval
                //tuple(List<int> approvedCardsId,List<Card> myDraftCards,List<Card> myApprovalPendingcards)
                }
            }
        }

    private async Task OnCreate()
        {
        //await authService.LoginUserMakingSure();
        await OnEdit(new TownCardDto());//pass townid,typeid if selected
        }
    private async Task OnEdit(TownCardDto dto)
        {
        await authService.LoginUserMakingSure();
        //eithert  admin or owner/creator only can edit
        //user should own the card otherwise not allowed
        if (clientConfig.IsAdmin == false) return;//|| dto.Id == 0

        var command = mapper.Map<CreateUpdateTownCardCommand>(dto);
        var parameters = new DialogParameters<CreateUpdateCard>{
                { x => x.model, command }
        };
        var options = new DialogOptions { CloseButton = true };// MaxWidth = MaxWidth.Medium, FullWidth = true
        var dialog = DialogService.Show<CreateUpdateCard>
        (dto.Id > 0 ? L["Create 'iCard'"] : L["Edit 'iCard'"], parameters, options);
        var state = await dialog.Result;
        if (!state.Canceled)
            {
            //this should be done if any changes happened only  otherwise not required on no change
            //so dialog result should confirm any changes happened or not
            await LoadServerData();
            //make sure result should show the modifications on result page
            //await LoadPage(pagedResponse.PageNumber);
            }
        }

    private async Task OpenViewDialog(TownCardDto card)//good
        {
        var parameters = new DialogParameters { ["TownCard"] = card };
        var dialog = DialogService.Show<ViewDialogCard>("View iCard", parameters);
        await dialog.Result; // No need to check the result since it's read-only
        }

    private async Task DeleteWithConfirmationDialog(TownCardDto card)
        {
        await authService.LoginUserMakingSure();
        // Delete Only owner or creator can do this
        //if (clientConfig.IsAdmin == false || card.Id == 0) return;
        var parameters = new DialogParameters { ["Name"] = card.Name + "/" + card.Id };
        var dialog = DialogService.Show<DeleteConfirmationDialog>
        ("Remove iCard", parameters);
        var result = await dialog.Result;
        if (!result.Canceled)
            {
            var res = await cardService.DeleteTownCardAsync(card.Id);
            if (res != null && res.Success)
                {
                //await LoadServerData();
                //insteaqd of reloading all(above), lets remove locally itself as like below
                //  Elements.RemoveAll(x => x.Id == card.Id);

                Snackbar.Add($"Removed iCard:({card.Name})", Severity.Success);
                }
            else Snackbar.Add($"Issue in Removing iCard ({card.Name})", Severity.Error);

            }
        }
        /*
    private bool dense = false;
    private bool hover = true;
    private bool striped = false;
    private bool bordered = false;
    private string searchStringTownName = "";
    private TownDto selectedItem1 = null;
    private HashSet<TownCardDto> selectedItems = new HashSet<TownCardDto>();

    private bool FilterFunc1(TownDto element) => FilterFunc(element, searchStringTownName);

    private bool FilterFunc(TownDto element, string searchString)
    {
    if (string.IsNullOrWhiteSpace(searchString))
    return true;
    if (element.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase))
    return true;
    // if (element.ShortName.Contains(searchString, StringComparison.OrdinalIgnoreCase))
    //     return true;
    //currently comparing only name & shortname, if anymore like description required then can be added here
    //or one searchstring property & make changes
    // if ($"{element.Number} {element.Position} {element.Molar}".Contains(searchString))
    //     return true;
    return false;
    }

    */
}
